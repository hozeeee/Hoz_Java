
# 数据库

如何设计一个关系型数据库？

    - 划分成两大模块：**存储系统**和**程序实例**。
    - 存储系统模块，就是把数据持久化存储到硬件设备上。
    - 程序实例模块，就是对存储模块的管理，包括如下模块：
      - 存储管理（将数据逻辑关系转化成物理存储关系）
      - 缓存机制（用于优化执行效率）
      - SQL解析
      - 日志管理
      - 权限划分（用于对多用户权限管理）
      - 容灾机制
      - **索引管理**（用于优化查询效率）
      - **锁管理**（使数据库支持并发操作）

</br>

## 索引

1. 为什么要使用**索引**？
    - 避免全局扫描，提高查询的速度。
    - 因为在数据量很大的表中，全表扫描会非常慢。索引提供了快速定位的能力，所以提高了查询速度。

2. 什么样的信息能成为索引？
    - 主键、唯一键、普通键等。

3. 索引的数据结构？
    - 二叉查找树
    - B_Tree
    - B+_Tree （MySQL）
    - Hash

4. 密集索引与稀疏索引的区别？
    - **密集索引**文件中的每个索引码值都对应一个索引值
      - 不仅保存了索引列的信息，还保存了其他列的信息
      - 一个表只能有一个密集索引，它决定了排列顺序
    - **稀疏索引**文件只为索引码的某些值建立索引项
      - 仅保存了索引列的信息
      - 通过稀疏索引查询后，只获取到数据的主键，还需要根据主键查询数据
    - InnoDB：
      - 若一个主键被定义，则该主键所谓密集索引
      - 若没有主键被定义，则该表的第一个唯一非空索引作为密集索引
      - 若以上条件都不符合， InnoDB 内部会生成一个隐藏主键作为密集索引
      - 非空主键索引存储相关键位和其对应的主键值，包含两次查找

以上索引问题的衍生问题：

1. 如何定位并优化慢查询 SQL ？
    - 需要结合经验来说。下面只说出大概思路：（TODO:3-07
      - 根据慢日志定位慢查询 sql
      - 使用 explain 等工具分析 sql
      - 修改 sql 或者尽量让 sql 走索引

2. 联合索引的最左匹配原则的成因？
    - "联合索引"就是多个字段组成的索引，多个字段是有顺序的，即`(a,b)`与`(b,a)`是不同的。
    - "联合索引"的原理是，先对第一个字段排序，然后依次对后面的字段排序。这就是联合索引使用的最左匹配原则的原因。
    - 下面以 `(a,b,c,d)` 为例。
    - "最左匹配原则"是指，多个查询条件时，会从最左的字段开始匹配，即第一个匹配`a`，然后到`b`，如此类推。
    - 假如查询条件中，`a`/`b`/`c`/`d`都使用`=`或`IN`查询，他们的顺序会被优化。
      - 即`WHERE d=? AND c=? AND b=? AND a=?`会被优化成`WHERE a=? AND b=? AND c=? AND d=?`
    - 假如查询条件中，其中一个使用了范围查询(如`>`/`<`/`BEWEEN`/`LIKE`)就会停止匹配。
      - 例如`WHERE a=? AND b=? AND c>? AND d=?`的`c`使用了范围查询，到它就终止了匹配，就用不了联合索引。

3. 索引是越多越好吗？
    - 数据量小的表不需要建立索引，否则会增加额外的索引开销。
    - 数据变更需要维护索引，因此更多的索引意味着更多的维护成本。
    - 更多的索引意味着需要更多的空间。

</br>

## 锁

1. MyISAM 与 InnoDB 关于锁方面的区别是什么？
    - MyISAM 默认用的是**表级锁**，不支持行级锁。
    - InnoDB 默认用的是**行级锁**，也支持表级锁。
    - 延申（锁的知识）：
      - "**读锁**"(IS)，就是数据被读取时加上的锁。也被称为**共享锁**，原因是在已有读锁的情况下，其他事务也能加上读锁。
      - "**写锁**"(IX)，就是数据被写入时加上的锁。也被称为**排他锁**，原因是在已有写锁的情况下，其他事务不能加上读锁或写锁。
      - 在查询语句中使用"写锁"：`SELECT * FROM tab_name WHERE ... FRO UPDATE;` 。
      - 在查询语句中使用"读锁"：`SELECT * FROM tab_name WHERE ... LOCK IN SHARE MODE;`
      - "表级锁"就是整个表被锁，"行级锁"就是某行数据被锁。
      - InnoDB ，当不走索引查询时，使用表级锁；当走索引查询时，使用行级锁。
    - 延申2（两个引擎的适合场景）：
      - MyISAM
        - 频繁执行全表 `count` 语句，因为其内部就保存了行数。
        - 对数据进行增删改的频率不高，查询非常频繁。
        - 没有事务。
      - InnoDB
        - 数据增删改查都相当频繁。
        - 可靠性要求比较高，要求支持事务。

2. 数据库事务的四大特性。
    - 原子性(Atomic)
    - 一致性(Consistency)
    - 隔离性(Isolation)
    - 持久型(Durability)

3. 事务隔离级别以及各级别下的并发访问问题。
    - 更新丢失：MySQL所有事务隔离级别都在数据库层面上均可避免，因为会自动加锁。
    - `READ-UNCOMMITTED`(RU) 该级别下可能会导致**脏读**。
      - 即当前事务能读取到另一个未提交的事务的数据。
    - `READ-COMMITTED`(RC) 该级别能**避免脏读**，是 Oracle 的默认级别。但可能会造成**不可重复读**。
      - 例如，当前事务不断对同一查询条件读取，结果都不一样，因为另一个事务也不断对该条记录进行修改。
    - `REPEATABLE-READ`(RR) 该级别能**避免不可重复读**，是 InnoDB 的默认级别。
      - 即当前事务开始了，读取到其中的数据，即使其他事务对该数据修改，也不会影响到当前事务的查询结果。
      - 理论上，此级别不能避免幻读，但实际测试中却实现了。（下一个问题解答）
    - `SERIALIZABLE` 该级别能**避免幻读**。
      - 当前事务读取多条数据并对其修改，但在当前事务提交前，另一个事务插入了一条新数据，那当前事务的修改就会出现"遗漏"。
    该级别能避免**幻读**，是 InnoDB 的默认级别。
    - 概括简单描述：
      - 脏读：读取了别人未提交的数据。
      - 不可重复读：本事务的两次读取期间有其他事务修改了数据。
      - 幻读：批量修改但未提交，其他事务插入新数据。
    - 相关命令：
      - 开启事务：`START TRANSACTION;`
      - 事务提交：`COMMIT;`
      - 事务回滚：`ROLLBACK;`
      - 修改事务隔离级别：`SET SESSION TRANSACTION ISOLATION LEVEL <隔离级别值>;`

4. InnoDB 可重复读隔离级别(RR)下如何避免幻读？
    - **当前读**与**快照读**：
      - 当前读：`SELECT ... LOCK IN SHARE MODE;`、`SELECT ... FOR UPDATE;`、`UPDATE`、`DELETE`、`INSERT`。
        - 即加了锁的增删改查。
        - 读取的最新记录，且防止了其他事务的并发修改。
      - 快照读：`SELETC`。
        - 即不加锁的非阻塞读。级别必须在 `SERIALIZABLE` 以下。
      - 关于 Gap 锁：
        - 如果 `WHERE` 条件全部命中，则不会用 Gap 锁。示例：
          - `id IN [1,2,3]` 若只命中 1、2 ，则不算全部命中
          - `id=3` 若不存在 3 的，则不算全部命中
        - 如果是使用非唯一索引或不走索引的读操作中，会使用 Gap 锁。
      答案：
        - 表象是快照读，伪 MVCC
        - 内在： next-key 锁（行级锁 + Gap 锁）

5. RC、RR 级别下的 InnoDB 的非阻塞读如何实现？
    - 数据行里的 `DB_TRX_ID`、`DB_ROLL_PTR`、`DB_ROW_ID` 字段
      - `DB_TRX_ID` 标识最后一次对本行数据操作事务
      - `DB_ROLL_PTR` 回滚指针
      - `DB_ROW_ID` 行号，也是在没有设置主键的情况下的隐藏主键
      - 还有其他隐藏列，例如标记可能被删除的 `DELETED`
    - Undo 日志
      - 当需要读取旧版本的数据时，需要沿着 **Undo 链**获取当时的数据
      - 包括 `INSERT Undo log` 和 `UPDATE Undo log` ：
        - `INSERT Undo log` 仅在回滚时才需要用到，事务提交后可以立即丢弃。
        - `UPDATE Undo log` 不仅在回滚时需要用到，在快照读时也会用到。
    - Read View 用来做可见性判断。即当快照读时，自动创建 Read View ，用来判断显示哪个版本的数据
    - 概括性描述：
      - RC 级别下，是获取到别的事务已提交的状态；
      - 而 RR 级别下，是获取到别的事务提交前的状态，即使别的事务已经提交了。

</br>
