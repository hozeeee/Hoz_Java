
# 数据库



1. 如何设计一个关系型数据库？
    - 划分成两大模块：**存储系统**和**程序实例**。
    - 存储系统模块，就是把数据持久化存储到硬件设备上。
    - 程序实例模块，就是对存储模块的管理，包括如下模块：
      - 存储管理（将数据逻辑关系转化成物理存储关系）
      - 缓存机制（用于优化执行效率）
      - SQL解析
      - 日志管理
      - 权限划分（用于对多用户权限管理）
      - 容灾机制
      - **索引管理**（用于优化查询效率）
      - **锁管理**（使数据库支持并发操作）




**索引**的相关问题：

1. 为什么要使用**索引**？
    - 避免全局扫描，提高查询的速度。
    - 因为在数据量很大的表中，全表扫描会非常慢。索引提供了快速定位的能力，所以提高了查询速度。

2. 什么样的信息能成为索引？
    - 主键、唯一键、普通键等。

3. 索引的数据结构？
    - 二叉查找树
    - B_Tree
    - B+_Tree （MySQL）
    - Hash

4. 密集索引与稀疏索引的区别？
    - **密集索引**文件中的每个索引码值都对应一个索引值
      - 不仅保存了索引列的信息，还保存了其他列的信息
      - 一个表只能有一个密集索引，它决定了排列顺序
    - **稀疏索引**文件只为索引码的某些值建立索引项
      - 仅保存了索引列的信息
      - 通过稀疏索引查询后，只获取到数据的主键，还需要根据主键查询数据
    - InnoDB：
      - 若一个主键被定义，则该主键所谓密集索引
      - 若没有主键被定义，则该表的第一个唯一非空索引作为密集索引
      - 若以上条件都不符合， InnoDB 内部会生成一个隐藏主键作为密集索引
      - 非空主键索引存储相关键位和其对应的主键值，包含两次查找

以上索引问题的衍生问题：

1. 如何定位并优化慢查询 SQL ？
    - 需要结合经验来说。下面只说出大概思路：（TODO:3-07
      - 根据慢日志定位慢查询 sql
      - 使用 explain 等工具分析 sql
      - 修改 sql 或者尽量让 sql 走索引

2. 联合索引的最左匹配原则的成因？
    - "联合索引"就是多个字段组成的索引，多个字段是有顺序的，即`(a,b)`与`(b,a)`是不同的。
    - "联合索引"的原理是，先对第一个字段排序，然后依次对后面的字段排序。这就是联合索引使用的最左匹配原则的原因。
    - 下面以 `(a,b,c,d)` 为例。
    - "最左匹配原则"是指，多个查询条件时，会从最左的字段开始匹配，即第一个匹配`a`，然后到`b`，如此类推。
    - 假如查询条件中，`a`/`b`/`c`/`d`都使用`=`或`IN`查询，他们的顺序会被优化。
      - 即`WHERE d=? AND c=? AND b=? AND a=?`会被优化成`WHERE a=? AND b=? AND c=? AND d=?`
    - 假如查询条件中，其中一个使用了范围查询(如`>`/`<`/`BEWEEN`/`LIKE`)就会停止匹配。
      - 例如`WHERE a=? AND b=? AND c>? AND d=?`的`c`使用了范围查询，到它就终止了匹配，就用不了联合索引。

3. 索引是越多越好吗？
    - 数据量小的表不需要建立索引，否则会增加额外的索引开销。
    - 数据变更需要维护索引，因此更多的索引意味着更多的维护成本。
    - 更多的索引意味着需要更多的空间。





</br>

## 锁

1. MyISAM 与 InnoDB 关于锁方面的区别是什么？
    - MyISAM 默认用的是**表级锁**，不支持行级锁。
    - InnoDB 默认用的是**行级锁**，也支持表级锁。
    - 延申（锁的知识）：
      - "**读锁**"(IS)，就是数据被读取时加上的锁。也被称为**共享锁**，原因是在已有读锁的情况下，其他事务也能加上读锁。
      - "**写锁**"(IX)，就是数据被写入时加上的锁。也被称为**排他锁**，原因是在已有写锁的情况下，其他事务不能加上读锁或写锁。
      - 在查询语句中使用"写锁"：`SELECT * FROM tab_name WHERE ... FRO UPDATE;` 。
      - 在查询语句中使用"读锁"：`SELECT * FROM tab_name WHERE ... LOCK IN SHARE MODE;`
      - "表级锁"就是整个表被锁，"行级锁"就是某行数据被锁。
      - InnoDB ，当不走索引查询时，使用表级锁；当走索引查询时，使用行级锁。
    - 延申2（两个引擎的适合场景）：
      - MyISAM
        - 频繁执行全表 `count` 语句，因为其内部就保存了行数。
        - 对数据进行增删改的频率不高，查询非常频繁。
        - 没有事务。
      - InnoDB
        - 数据增删改查都相当频繁。
        - 可靠性要求比较高，要求支持事务。

2. 数据库事务的四大特性。
    - 原子性(Atomic)
    - 一致性(Consistency)
    - 隔离性(Isolation)
    - 持久型(Durability)

3. 事务隔离级别以及各级别下的并发访问问题。
    - `READ-UNCOMMITTED` 该级别下可能会导致**脏读**。
    - `READ-COMMITTED` 该级别能避免脏读。
    - ``
    - `REPEATABLE-READ` 该级别能避免**幻读**。
    - ``

    - 相关命令：
      - 开启事务：`START TRANSACTION;`
      - 事务提交：`COMMIT;`
      - 事务回滚：`ROLLBACK;`
      - 修改事务隔离级别：`SET SESSION TRANSACTION ISOLATION LEVEL <隔离级别值>;`


更新丢失：MySQL所有事务隔离级别都在数据库层面上均可避免，因为会自动加锁。



4. InnoDB 可重复读隔离级别下如何避免幻读？








5. RC、RR 级别下的 InnoDB 的非阻塞读如何实现？















</br>






















</br>






















</br>






















</br>






















</br>






















</br>






















</br>






















</br>


























































