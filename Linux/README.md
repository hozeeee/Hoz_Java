
# 简介

Linux 分**内核版本**和**发行版本**。

内核版本的下载可以到 [https://www.kernel.org/](https://www.kernel.org/) ，下面简单说一下版本号的含义：

- 版本号分三部分：主版本号、次版本号、末版本号。与其他软件的版本号命名相同
- 次版本号是奇数的为开发版；偶数的为稳定版。 (2.6 之后取消这种规定)

发行版本，是其他厂商定制的，可能需要付费，下面说几个常用的：

- RedHat Enterprise Linux ，付费，提供技术支持，稳定
- Fedora ，免费，提供社区，比较新，稳定低于前者
- [**CentOS**](https://www.centos.org/) ，免费，基于 RedHat Enterprise Linux ，在它基础上去了商标，推荐使用。
- Debian ， Ubuntu ，提供图形界面

学习 Linux 建议使用 **VirtualBox** 虚拟机， [下载地址](https://www.virtualbox.org/wiki/Downloads) 。

- 在虚拟机中，按右边的 `Ctrl` 退出"鼠标独享"。

在命令行终端中，以 `$` 开头的是普通用户，以 `#` 开头的是管理员用户。

常见目录介绍：

- `/`: 根目录
- `/root`: root 用户的主目录
- `/home/<username>`: 普通用户的主目录
- `/etc`: 配置文件目录
- `/bin`: 存放可执行命令的目录
- `/sbin`: 存放管理命令的目录
- `/usr/bin`、`/usr/sbin`: 系统预装的其他命令

命令的需要多个参数，可以"连写"，如 `ls -l -a -R` 可以写成 `ls -laR` ，三个字母的顺序任意。

</br>
</br>

# 常用命令

## 帮助命令

### man

`man` 是 `manual` 的缩写。

帮助文档分 9 章，如果是查询第 1 章，`1` 可以忽略。

各章节的内容如下 (通过 `man 7 man` 获取更详细)：

1. Commands: 用户可从 shell 运行的命令
2. System calls: 必须由内核完成的功能
3. Library calls: 大多数 libc 函数，例如 `qsort(3)`
4. Special files: `/dev` 目录中的文件
5. File formats and conventions: `/etc/passwd` 等认类可读的文件的格式说明
6. Games
7. Macro packages and conventions: 文件系统标准描述，网络协议，ASCCII和其他字符集，还有你眼前这份文档
8. System management commands: 类似 `mount(8)` 等命令，大部分只能由 `root` 权限用户执行
9. Kernel routines: 废弃章节。

### help

**内部命令**使用 `help` 获取帮助，如 `# help cd` 。

内部命令就是， shell 自带的命令。

### info

`info` 比 `help` 更详细，可以作为 `help` 的补充。

示例： `# info ls` 。

</br>

## 文件的复制移动

### pwd

用于显示当前目录名称。

### cd

用于更改当前的操作目录。

`cd -` 可以回到前一个进入"当前目录"。

### ls

用于查看当前目录下的文件，常用参数如下

- `-l` 长格式显示
- `-a` 显示隐藏文件
- `-r` 倒序显示
- `-t` 按时间顺序显示
- `-R` 递归显示

### mkdir

`mkdir ./a` 或 `mkdir a` 在当前目录下创建 a 文件夹。

`mkdir /a` 在根目录下创建 a 文件夹。

`mkdir -p a/b/c/d` 可以一次创建多级目录。

### rmdir

`rmdir a` 只能删除 a 文件夹（且 a 必须是空文件夹）

`rm -r a` 可以删除非空的文件夹和文件

### cp

`cp [options] [source_path] [target_path]` 复制文件到指定路径。

常用参数介绍：

- `-r`: 默认情况下， `cp` 只能复制文件，若需要复制目录，请使用此参数。
- `-v`: 默认情况下，复制没有进度条，此参数可以显示进度。
- `-p`: 默认情况下，复制后的文件的属性(如作者、修改时间)会发生改变，使用此参数可以保留源文件的用户、权限、时间等文件属性。
- `-a`: 是 `-p` 的"升级版"，等同于 `-dpR` ，保留源文件的所有属性。

### mv

`mv [options] [source_path] [target_path]` 移动目录或文件，若目标目录或文件名与源目录或文件不相同，则同时进行了重名名操作。

</br>

## 文本查看

### cat

在终端上显示文本内容

### head

查看本舰开头

### tail

查看文件结尾

-f 文件内容更新后，显示信息同步更新

### wc

统计文件内容信息

</br>

## 打包、压缩、解压缩

由于历史原因，打包和压缩是两个步骤。

打包： `tar cf [target_file] [source_dir]` 把 `[source_dir]` 目录的所有文件都压缩到 `[target_file]` 。

解包： `tar xzf [package_file] -C [target_dir]` 把压缩包文件解压到 `[target_dir]` ， `xjf` 同理。

- `c` 参数表示打包。
- `x` 参数表示解包。
- `f` 参数表示指定操作类型为文件。
- `tar` 命令的参数是不带 `-` 的，这点和大多数的命令有所区别。
- `z` 参数代表打包的时候就进行压缩。也可以单独使用 `gzip` 进行压缩，注意文件名以 `*.tar.gz` 命名。
- `j` 参数也代表打包的时候就进行压缩。也可以单独使用 `bzip2` 进行压缩，注意文件名以 `*.tar.bz2` 命名。压缩比例比 `gzip` 要高，所以压缩耗时也更长。

关于扩展名：

- `gzip` 的压缩包的扩展名，除了上面说的，还可能是 `.tgz` 。
- `bzip2` 的压缩包的扩展名，除了上面说的，还可能是 `.tar.bzip2` 、 `.tbz2` 。

</br>
</br>

# vi(m) 编辑器

vim 是基于 vi 的一个编辑器。

有 4 种输入模式：

- 正常模式：
  - 默认进入的就是正常模式，在其他模式下，任意模式下通过键盘的 `esc` 键也能回到此模式。
  - 光标移动操作：
    - 按 `h` 使光标向**左**移动；
    - 按 `j` 使光标向**下**移动；
    - 按 `k` 使光标向**上**移动；
    - 按 `l` 使光标向**右**移动。
    - 按 `^` 使光标移动到当前**行开头**；
    - 按 `$` 使光标移动到当前**行末尾**；
    - 按 `G` 使光标移动到**最后一行**；
    - 按 `<n>G` (即`<n> shift+g`) 可以把光标移动到**第`<n>`行**。
  - 复制：
    - 按 `yy` 复制光标所在的整行；
    - 按 `<n>yy` 表示从当前行开始，复制 `<n>` 行，如 `3yy` 表示复制三行；
    - 按 `y$` 表示复制从光标位置到该行末尾；
  - 剪切：
    - 按 `dd` 剪切光标坐在的整行；
    - 配合"方向键"(下面用`<orient>`表示)使用：
      - 按 `dh` 剪切光标的左边的单个字符；
      - 按 `dl` 剪切光标所在的字符；
      - 按 `dj` 剪切光标所在行和下一行的内容；
      - 按 `dk` 剪切光标所在行和上一行的内容；
    - 按 `d<orient>` 剪切光标到特定方向键位置的内容，如 `dl` 就是删除(`<orient>`是`h`/`j`/`k`/`l`中的一个)；
    - 按 `d$` 表示剪切从光标位置到改行末尾。
  - 按 `p` **粘贴**复制或剪切的内容。
  - 按 `x` **删除**光标所在的**单个**字符。
  - 按 `r` 后输入字符，可**替换**光标所在的**单个**字符。
  - 按 `u` **撤销**上一个命令。
  - 按 `Ctrl + r` **还原**上一个被撤销的命令。

- 插入模式：
  - 在插入模式下，可以正常输入文本。在正常模式下，有以下 6 种方式进入此模式：
    - `i` 表示在当前光标处进入插入模式；
    - `I` 表示在当前行开头进入插入模式；
    - `a` 表示在当前光标后(一个字符的位置)进入插入模式；
    - `A` 表示在当前行末尾进入插入模式；
    - `o` 表示在当前行的下一行插入一个新行，在新行的开头进入插入模式；
    - `O` 表示在当前行的上一行插入一个新行，在新行的开头进入插入模式；

- 命令模式(末行模式)：
  - 正常模式下按 `:` 接需要执行的命令。
    - 输入 `set nu` 后，显示每一行的行号； `set nonu` 则是关闭行号显示。
    - 输入 `w <filename>?` 后，将内容**保存**到`<filename>`(可以包含路径)；若通过打开文件的方式，`<filename>`则可以省略，表示保存到源文件中。
    - 输入 `q` 后，会**退出** vi(m) 编辑器，文件必须已保存或未修改。
    - 输入 `q!` 后，表示**不保存**退出。
    - 输入 `wq` 后，是 `w` 和 `q` 的组合，表示保存并退出。
    - 输入 `!<command>` 后，表示**暂时离开编辑器**，**并执行`<command>`命令**，如`!ifconfig`会查看ip地址，然后再回来继续编辑。
    - 关于文本**替换**：
      - 输入 `s/<souce_string>/<new_string>` 后，可以将**光标所在行**的**第一个** `<souce_string>` 的内容替换为 `<new_string>` 。
      - 输入 `%s/<souce_string>/<new_string>` 后，可以**全文替换**。
      - 输入 `%s/<souce_string>/<new_string>/g` 后，可以全文**替换所有**。
      - 输入 `<start_line>,<end_line>s/<souce_string>/<new_string>` 后，可以**针对第 `<start_line>` 行到 `<end_line>` 行**进行替换。
  - 正常模式下按 `/` 接需要**查找**的内容，如`/x`后按回车，就可以高亮显示`x`的内容。

- 可视模式：
  - 可视模式的作用是选中特定的区域，然后进行编辑操作。
  - 正常模式下按 `v` 进入**字符**可视模式，以字符为单位选中。
  - 正常模式下按 `V` 进入**行**可视模式，以行为单位选中。
  - 正常模式下按 `Ctrl + v` 进入**块**可视模式，以"矩形"的方式框选。
  - 可视模式下选中了区域，按上面介绍的命令就可以进行操作，如按`i`进入插入模式，就会对选中的多行输入相同的内容

## 其他

- `exit` 退出当前登陆的用户。

</br>
</br>

# 用户与权限管理

用户类型有两种： root 用户和普通用户。

- `useradd <username>` 新建 `<username>` 用户
- `userdel <user>?` 删除 `<user>` 用户 (建议带`-r`参数,表示连同删除`/home`目录下该用户的文件夹)
- `passwd <user>?` 修改 `<user>` 用户的密码；当省略 `<user>` 则是对当前用户修改密码 (输入命令后会提示输入新密码)
- `usermod <options> <user>` 修改 `<user>` 用户属性
- `chage <options> <user>` 修改 `<user>` 用户密码的过期时间

查看已有的用户：

- `id <username>` 确定是否存在 `<username>` 用户
- `cat /etc/shadow` 会包含已创建的用户
- `cat /etc/passwd` 也会包含已创建的用户

操作用户组：

- `groupadd <groupname>` 新建 `<groupname>` 用户组，然后通过 `usermode` 命令修改用户的所属用户组
  - 新建用户时，也可以添加选项 `-g <groupname>` 可以在创建用户的同时加入 `<groupname>` 用户组
- `groupdel <groupname>` 删除用户组

</br>
</br>

# 用户切换、命令权限

使用 `su` 命令可以临时切换用户，用于执行特定的命令。

- `su - <user>` 的 `-` 表示"完全切换"，否则可能身处无权限访问的目录下。
- 在"临时用户"下，可以使用该用户的所有权限。
- 一样是通过 `exit` 退出"临时用户"。
- root 用户可以无需密码就切换到普通用户，而普通用户切换其他用户则需要输入密码。

使用 `sudo` 以其他用户身份执行命令，但前提是该用户( root 用户)已经授权给本用户。

- 如 `sudo -u root shutdown -h 30` 中， `-u root` 表示以 root 用户身份执行命令，可以省略，默认就是以 root 身份执行； `shutdown -h 30` 是目标命令和参数。

管理员账号下，使用 `visudo` 可以给特定的用户或用户组添加某个命令的权限。

- 执行 `visudo` 后进入配置文件的编辑，文件内包含用例。
- 配置文件中以 `#` 开头的是注释内容。
- 简单说一下配置：
  - `%wheel localhost=/sbin/shutdown -h now`: `%wheel`表示被赋权限的用户组，也可以指定单个用户(省略`%`)；`localhost`是权限主机；`/sbin/shutdown -h now`是给用户(组)开放权限的命令，命令可以指定参数。
  - `user1 ALL=/sbin/mount /mnt/cdrom, /sbin/unmount /mnt/cdrom`: 可以同时指定多个开放权限的命令，用`,`分隔；`ALL`表示所有主机，包括远程主机。
  - `user2 ALL=(ALL) NOPASSWD: ALL`: `(ALL)`表示开放所有命令的权限；`NOPASSWD: ALL`是可选配置，表示不用密码，不建议开启。
- 若不知道**命令所在的位置**，执行 **`which <command>`** 即可获取。

</br>
</br>

# 用户和用户组的配置文件

`vim /etc/passwd`: 该文件会保存已创建的**用户**。会有多行，一行代表一个用户，有 7 个字段，用 `:` 分隔，如 `root:x:0:0:root:/root:/bin/bash` ：

1. 第一部分， `root` 表示**用户名**；
2. 第二部分， `x` 表示**需要使用密码登陆**，若不需要密码登陆，缺省即可；
3. 第三部分， `0` 表示 **uid** ，即用户 id ， Linux 中区分用户就是通过此 id ；
4. 第四部分， `0` 表示 **gid** ，即用户组 id ， Linux 中区分用户组就是通过此 id ；
5. 第五部分， `root` 表示**描述**，可以缺省；
6. 第六部分， `/root` 表示该用户的 **home 目录**；
7. 第七部分， `/bin/bash` 表示该用户的**命令解析器**，当设为 `/sbin/nologin` 表示**不允许**该用户**登陆**终端。

`vim /etc/shadow`: 该文件保存**用户密码**相关的配置。同样会有多行，一行代表一个用户，有 9 个字段，同样用 `:` 分隔，如 `user1:$6$....:17834:0:99999:7:::` ，下面只介绍前两部分：

1. 第一部分， `user1` 表示**用户名称**；
2. 第二部分， `$6$....` 表示加密过的密码，一般以 `$6$` 开头，需要注意，即使两个用户的密码相同，这里的值也不会相同。

`vim /etc/group`: 该文件表示已创建的**用户组**。还是多行，一行代表一个用户组，有 4 个字段，用 `:` 分隔，如 `root:x:0:rootuser` ：

1. 第一部分， `root` 表示**用户组名称**；
2. 第二部分， `x` 表示**需要使用密码登陆**，若不需要密码登陆，缺省即可；
3. 第三部分， `0` 表示 **gid** ，即用户组 id ， Linux 中区分用户组就是通过此 id ，与 `/etc/passwd` 文件对应；
4. 第四部分， `rootuser` 是一个用户，该用户的"其他用户组"就属于 `root` 用户组，即用户可以同时属于多个用户组，多个用 `,` 分隔。

</br>
</br>

# 关于文件的权限

`ls -l` 可以获取当前目录的文件的详细列表，其中包含文件的权限信息。示例：`-rw-r-xr-- 1 username groupname mtime filename` 。

1. 第 1 位，代表文件的类型，有如下几种：
    - `-` 表示普通文件
    - `d` 表示目录文件
    - `b` 表示块特殊文件，如硬盘设备
    - `c` 表示字符特殊文件，如 shell
    - `l` 表示符号链接
    - `f` 表示命名管道
    - `s` 表示套接字文件

2. 第 2~10 位，表示文件处于不同用户/用户组下的权限，
    - 前三位表示：文件属**用户**的权限
    - 中间三位表示：文件属**组**的权限
    - 后三位表示：**其他用户**的权限
    - 每一位出现的字符都是 `r`/`w`/`x`/`4`/`2`/`1`/`-` 中的一个。
    - 对于普通文件，字符的含义是：
      - `r` 表示可读，等效于 `4`
      - `w` 表示可写，等效于 `2`
      - `x` 表示可执行，等效于 `1`
      - `-` 表示空
    - 对于目录文件，字符的含义是：
      - `x` 表示可**进入**目录
      - `rx` 表示可**显示**目录内的文件名
      - `wx` 表示可**修改**目录内的文件名

修改文件的权限的命令如下：

- `chmod [u/g/o/a][+/-/=] <file>` 修改文件、目录权限。
  - `[u/g/o/a]` 的意思是值为 `u`/`g`/`o`/`a` 中的一个，其含义分别是：
    - `u` 表示设置"所属用户位"的权限
    - `g` 表示设置"所属组位"的权限
    - `o` 表示设置"其他用户位"的权限
    - `a` 表示所有的"权限位"一起设置
  - `[+/-/=]` 表示运算符，值为 ``/``/`` 中的一个，其含义分别是：
    - `+` 表示新增权限
    - `-` 表示减少权限
    - `=` 表示设置权限
  - 示例如下：(假设`testfile`文件的权限值为 `rw-r--r--`,例子间无联系)
    - `chmod u+x /testfile` 表示"所属用户位"增加"执行"权限，执行后的权限变为 `rwxr--r--`
    - `chmod 755 /testfile` 表示直接设置权限，执行后的权限变为 `rwxr-xr-x`
    - `chmod a-r /testfile` 表示所有的"权限位"都减少读权限，即执行后的权限变为 `-w-------`

- `chown <target_user>? :<group_name>? <file>` 更改所属用户、所属组。示例如下：
  - `chown user1 /test` 把 `/test` 目录的所属用户改为 `user1`
  - `chown :group1 /test` 把 `/test` 目录的所属组改为 `group1`

- `chgrp` 单独修改所属组，不常用

</br>
</br>

# 网络管理

CentOS7 之前，网卡的命名都是以 `eth*` 的方式命名，好处是方便批量处理；而 CentOS7 及以后，网卡的命名规则如下：

- `eno1` 表示板载网卡
- `ens33` 表示 PCI-E 网卡
- `enp0s3` 表示 无法获取物理信息的 PCI-E 网卡

CentOS7 及以后的版本，也可以通过修改配置文件，实现以 `eth*` 的方式命名网卡，具体不细说了。

root 用户可以直接执行 `ifconfig` 查看网卡设备；普通用户则需要使用 `/sbin/ifconfig` 。

`mii-tool eth0` 可以查看 `eth0` 网卡的物理连接情况。

`route -n` 查看网关， `-n` 表示不解析主机名。

`ifup <网卡>` 和 `ifdown <网卡>` 是分别对网卡打开和关闭。

故障排除相关的命令：

- `ping www.baidu.com` 检测与该主机之间的链路是否为通，要考虑是否防火墙拦截了。
- `traceroute -w 1 www.baidu.com` 可以检测与目标主机之间的网络情况，其中 `-w 1` 表示超时时只等待 1 秒。
- `mtr` 可以动态(以表格的形式)显示本主机各个连接的具体情况。
- `nslookup www.baidu.com` 将域名解析成 IP 地址。
- `telnet www.baidu.com 80` 检测到目标主机的端口是否畅通。若提示"未找到命令"，可以通过 `yum install telnet` 安装。
- `tcpdump -i any -n host 10.0.0.1 and port 80 -w /tmp/filename` 抓包并保存到文件。
- `netstat -ntpl` 查看本机启动的服务。 `ss` 命令与此命令类似。

</br>
</br>

# 软件包管理

包管理有两个：

- CentOS、RedHat 使用 yum 包管理器，软件包的格式为 rpm ，下面只介绍这种；
- Debian、Ubuntu 使用 apt 包管理器，软件包的格式为 deb 。

rpm 包命名格式，以 `vim-common-7.4.10-5.el7.x86_64.rpm` 为例：

- `vim-common` 是软件名
- `7.4.10-5` 是软件版本
- `el7` 是系统版本
- `x86_64` 是平台

`rpm` 命令的常用参数：

- `-q` 查询软件包
- `-i` 安装软件包
- `-e` 卸载软件包软件包

`yum` 命令的常用参数：(建议改成国内镜像源)

- `install` 安装软件包
- `remove` 卸载软件包
- `list`/`grouplist` 查看软件包
- `update` 升级软件包

源代码编译方式安装：

1. `wget <url>` 下载压缩包。
2. `tar <file>` 解压缩包。
3. 进入解压后的目录， 执行 `configure` 文件，若没有，则查看 `README*` 文件。
4. 同样在该目录下，执行 `gmake -j2` 执行编译。完成后会在当前目录下生成 `build` 目录。
5. 还是在该目录下，执行 `make install` 进行安装。

内核升级：(有两种方式)

- 通过 `yum`
  - 默认的 `yum` 仓库能安装的内核版本都比较低，但可以通过 `yum install epel-release -y` 扩展仓库。
  - 通过上面的扩展之后，执行 `yum install kernal` 安装仓库内最新版本的内核；若需要安装指定版本，则执行如 `yum install kernal-3.10.0` 的命令。

- 通过源代码编译方式安装
  - 下载内核压缩包： [http://www.kernel.org/](http://www.kernel.org/) 。
  - 安装依赖： `yum install gcc gcc-c++ make ncurses-devel openssl-devel elfutils-libelf-devel` ，若之前安装了，可能就不需要再安装。
  - 解压： `tar vxf linux-5.1.14.tar.xz -C /usr/src/kernals/` 。
  - 定位到解压后的目录： `cd /usr/src/kernals/linux-5.1.14/` 。
  - 指定需要安装的配置项： `make menuconfig` ，执行后会进入一个图形界面，可以选择功能安装。结束后会回到命令行终端，且生成 `.config` 文件。
  - 若想使用原来的配置项，可以进入 `/boot` 目录，把 `config-....x86_64` 文件覆盖成上面说的 `.config` 文件，即执行如 `cp config-....x86_64 /usr/src/kernals/linux-5.1.14/.config` 。覆盖完成后需要再执行 `make menuconfig` 。
  - `lscpu` 查看硬件情况(看一下内核数)。
  - 编译： `make -j2 all` ，表示使用 2 个核心进行编译。至少要保留 10 GB 的可用空间。
  - 安装内核模块： `make modules_install` 。
  - 安装内核： `make install` 。
  - 重启 Linux ： `reboot` 。
  - 查看内核版本号： `uname -r` 。

</br>
</br>

# 进程管理

查看进程：

- `ps` 查看进程，常用参数是 `-eLf` 。
- `pstree` 以树状结构查看进程。
- `top` 动态显示系统及进程的情况，类似于 window 的"任务管理器"。

操作进程：

- 后台执行程序： `./program.sh &` ， `&` 就是表示在后台执行，前台的终端还能输入其他命令。
- 查看后台执行的程序： `jobs` 。
- 把后台的程序调回到前台： `fg 1` ，其中 `1` 是通过 `jobs` 获取到的序号。
- 挂起程序(即程序会被放到后台,且暂停执行)： 使用快捷键 `Ctrl + z` 。
- 若想把挂起程序继续执行，同样是 `jobs` 获取序号，然后使用 `bg 1` 把程序在后台执行；若想把程序在前台执行，则使用 `fg 1` 命令。

- 执行程序的时候，可以改变它的优先级，使用 `nice -n 10 ./program.sh` ，其中 `10` 就是优先级(越小优先级越大)。注意，"nice"的值范围是 -20 到 19 。
- 若想对已执行的程序修改其优先级，在使用 `renice -n 15 <pid>` ，其中 `<pid>` 是程序的 ID 。

- `kill -l` 可以查看相关的命令。
  - 如 `SIGINT` 是通知前台程序组终止进程，等效于快捷键 `Ctrl + c`
  - 如 `SIGKILL` 是立即结束程序，不能被阻塞和处理。示例： `kill -9 <pid>`

守护进程(daemon)：随系统开机的时候启动。

与守护进程类似的是 `nphup <program> &` 启动的程序，它会忽略 hangup(挂起) 的信号，即关闭终端也继续执行。

screen 环境：

- 使用 `screen` 命令进入 screen 环境，该环境下运行的程序，可以避免由于网络终端而导致的命令终端。
- 使用快捷键 `Ctrl + a` ，然后按 `d` 退出 screen 环境。(d 是 detached 的缩写)
- 若想再进去 screen 环境，可以使用 `screen -ls` 查看 screen 的会话，然后使用 `screen -r <sessionId>` 恢复会话。

</br>
</br>

TODO: 42....
